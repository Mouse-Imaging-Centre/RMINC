% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/minc_parallel.R
\name{pMincApply}
\alias{pMincApply}
\title{Parallel MincApply}
\usage{
pMincApply(filenames, fun, ..., mask = NULL, tinyMask = FALSE,
  batches = 4, method = c("local", "snowfall", "pbs", "sge", "none"),
  cores = getOption("mc.cores", 2L), resources = list(), packages = NULL,
  vmem = NULL, walltime = NULL, workers = batches, temp_dir = tempdir(),
  cleanup = TRUE, collate = simplify2minc)
}
\arguments{
\item{filenames}{Paths to the minc files to be applied accross}

\item{fun}{The function to apply}

\item{...}{Additional arguments to fun through \link{mincApplyRCPP} see 
notes for a warnings}

\item{mask}{The path to a mask for the minc files}

\item{tinyMask}{whether to use a small subset of voxels to test the computation}

\item{batches}{The number of jobs to break the computation into}

\item{method}{The parallelization method, local and snowfall perform 
computations on multiple cores (snowfall is an alias for local for backcompatibility)
pbs refers to a torque queueing system, and sge refers to an sge refers to the
sge queueing system.}

\item{cores}{The number of cores to use in local computation}

\item{resources}{A list of resources to request from the queueing system
common examples including vmem, walltime, nodes, and modules see
\code{system.file("parallel/pbs_script.tmpl", package = "RMINC")} and
\code{system.file("parallel/sge_script.tmpl", package = "RMINC")} for
more details}

\item{packages}{Character vector of packages to load for all jobs}

\item{vmem}{The number of gigabytes of memory to request for each batched
job. It is a compatibility argument and will overload \code{vmem} 
set in the resource list (if it is defined)}

\item{walltime}{The amount of walltime to request for each batched job.
It is a compatibility argument and will overwrite \code{walltime}
set in the resource list (if it is defined)}

\item{workers}{The number of workers to use. It is a compatibility option
and will overwrite \code{batches} if it is supplied.}

\item{temp_dir}{A path to a temporary directory to hold the job registry
created when using a true queuing system and for writing temporary mask
files. This must be a location read/writable by all nodes when using a
true queuing system (so /tmp will not work).}

\item{cleanup}{Whether to clean up registry after a queue parallelization job}

\item{collate}{A function to be applied to collapse the results of the
the pMincApply. Defaults to \link{simplify2minc}.}
}
\value{
The results of applying \code{fun} to each voxel accross \code{filenames}
after collation with \code{collate}
}
\description{
Apply an arbitrary R function across a collection of minc files, distributing
the computation to multiple cores or workers on a grid computing environment
}
\details{
This is a convenience wrapper for two underlying functions \link{qMincApply}
and \link{mcMincApply} for queueing and multicore processing respectively. Each of
these functions divides all of the voxels that are masked by \code{mask} into
\code{batches}. Batches are processed in parallel, with calling
\link{mincApplyRCPP} to process the voxels in the batch. Arguments passed in through
\code{...} will be bound by \link{mincApplyRCPP} before \code{fun}, so be wary
of potential partial matches. When in doubt, partially apply your function before
hand, and do not rely on positional matching.
}

